---
title: "RPolarAverage3"
output: html_document
date: "2023-11-01"
---

```{r}
rm(list=ls())
ls()
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(RColorBrewer)
knitr::opts_chunk$set(echo = TRUE)
#library(readtextgrid)
library(devtools)
load_all("/Users/yayaorigami/Documents/readtextgrid")
library(tibble)
library(dplyr)
#library(jsonlite)
library(rjson)
library(eply)
#library(textgRid)
library(extrafont)
library(Cairo)
#font_import()
# Load the DejaVu Sans font family
#loadfonts()
```

```{r}
loadTraces <- function(directory_name, tiernameAll = c(""), categoriesAll = list(c()), layersAll = c(""),
                       mergeCategories = c(FALSE)){
  
  metaDataFile <- paste(directory_name, "metadata.json", sep = "/") #is this an ok approach?
  #is it guaranteed that the meta file will be called metadata, and is in the same directory level
  
  if (!file.exists(metaDataFile)){
    stop("metadata file does not exist in given directory")
  }
  
  metaData <- fromJSON(file = metaDataFile)
  filesAll <- metaData$files
  
  #type checking
  #c("[]") already acts like a string "", so only need to check categoriesAll
  
  if (inherits(categoriesAll, "character") || inherits(categoriesAll, "NULL")){
    categoriesAll <- list(categoriesAll)
  }
  
  #some initial set-up
  rawTraces <- data.frame()
  column_names <- c('file_number', 'itemNumber_inFile', 'segment', 'x', 'y')
  rawTraces <- rbind(rawTraces, column_names)
  allRowsTextGrids <- list()
  
  #padding
  for (i in 1:length(categoriesAll)){
    if (length(tiernameAll) < length(categoriesAll)){
      tiernameAll <- append(tiernameAll, tiernameAll[[1]])
    }
    if (length(layersAll) < length(categoriesAll)){
      layersAll <- append(layersAll, layersAll[[1]]) #maybe edit later to layersAll[]
    }
    if (length(mergeCategories) < length(categoriesAll)){
      mergeCategories <- append(mergeCategories, mergeCategories[[1]])
    }
  }
  #beginning for loop
  for (item in 1:length(categoriesAll)){
    
    #selecting layer level: future work be able to detect all, rather than setting tongue as default
    if(layersAll[[item]]==""){
      traces_raw <- metaData$traces[['tongue']]
    }else{
      traces_raw <- metaData$traces[[layersAll[[item]]]]
    }
    
    #traces_raw <- metaData$traces[['palate']]
    #traces_raw <- metaData$traces$tongue
    
    tiername = tiernameAll[[item]]
    categories = categoriesAll[[item]]
    
    
    
    #if only metadata xy data
    if (tiernameAll[[item]] == "" && length(categoriesAll[[item]]) == 1 && categoriesAll[[item]] == ""){
      #order of logic matters
      rawTraces <- rbind(rawTraces, tracesWithoutTier(metaDataFile, layersAll[[item]]))
      
    }else{ #actually open textgrids and check categories
      for (individualFile in 1:length(filesAll)){
        #accessing text grid files
        recording_name <- filesAll[[individualFile]]$.TextGrid
        plainTextname <- filesAll[[individualFile]]$name
        #used to access text grid files
        fullFilePath <- file.path(directory_name, recording_name)
        #print(fullFilePath)
        
        #cur_recording <- metaData$traces$tongue$files[[(filesAll[[individualFile]]$name)]]
        cur_recording <- traces_raw$files[[(filesAll[[individualFile]]$name)]]
        
        if (is.null(cur_recording)){
          listExists <- 0
        }else{
          # listExists <- max(unlist(lapply(metaData$traces$tongue$files[[(filesAll[[individualFile]]$name)]], length)))
          listExists <- max(unlist(lapply(traces_raw$files[[(filesAll[[individualFile]]$name)]], length)))
        }
        
        #read text grid if it is not empty
        if (listExists > 1){
          #read in text grid data but only if recording > 0
          #Reading Text Grid
          errorCode = 0
          tryCatch({
            textGridDataFile <- read_textgrid(fullFilePath)
          }, error = function(e){
            message("cannot open textgrid")
            errorCode = 1
          })
          if(errorCode==1){ #skip this file and move onto next
            next
          }
          
          #time to parse TIERS
          intervalData <- textGridDataFile[textGridDataFile$tier_type == "IntervalTier", ]
          if (nchar(tiername)!=0){
            if (tiername %in% intervalData$tier_name){
              intervalData <- intervalData[intervalData$tier_name == tiername,]
            }else{ #you have annotation, but not in the proper tier
              message("skipping this textgrid file, as annotations are not in the proper tier")
              message(plainTextname)
              next
            }
          }
          
          #CATEGORIES
          if (length(categories) == 0){ #read all segments
            #intervalData <- intervalData[nchar(intervalData$text) == 1 | nchar(intervalData$text) == 2, ] 
            #just gets everything, n^j is two characters
            intervalData <- intervalData[nchar(intervalData$text) !=0, ] 
            #absolutely gets everything, that is not a blank space
          } else { #specific categories specified
            intervalData <- intervalData[intervalData$text %in% categories, ]
          }
          
          fileNumber <- (intervalData$file)[1]
          
          
          df <- intervalData
          
          #attaching midpoint and plainTextname for later textgrid access
          df <- df %>% mutate(mid_point = (df$xmin + df$xmax)/2) #THIS IS FINE
          df <- df %>% mutate(plainTextName = plainTextname)
          
          textTiers <-  textGridDataFile[textGridDataFile$tier_type == "TextTier",]
          
          if (nrow(df) > 0){
            #1) using df min and max, isolate textTiers fragment
            #2) out of fragment, find textTier closest to midpoint
            frameNumberList <- list()
            for (midpoint in 1:length(df$mid_point)){
              min <- (df$xmin)[[midpoint]]
              max <- df$xmax[[midpoint]]
              textTierSection <- textTiers[textTiers$xmin >= min & textTiers$xmin <= max, ]
              
              if (nrow(textTierSection)!=0){
                frameNumber <- (textTierSection[which.min(abs(textTierSection$xmin - df$mid_point[[midpoint]])), ])$text
              }else{ #special case
                frameNumber <- (textTiers[which.min(abs(textTiers$xmin - df$mid_point[[midpoint]])), ])$text
              }
              frameNumberList = append(frameNumberList, frameNumber)
            }
            
            frameNumberList <- unlist(frameNumberList)
            df <- df %>% mutate(frame = frameNumberList)
            
            for (midpoint in 1:length(df$mid_point)){
              allRowsTextGrids <- rbind(allRowsTextGrids, data.frame(df[midpoint,])) #necessary in case multiple text grid files
            }
          }
        }else{
          #print("skipping this textgrid file")
        }
        
      }
      #return(allRowsTextGrids)
      #extract xy data separately once we have all the data
      
      for(frame in 1:length(allRowsTextGrids$frame)){
        frameNumber = (allRowsTextGrids$frame)[[frame]]
        plainTextname <- allRowsTextGrids$plainTextName[[frame]]
        #xyFileData <- (metaData$traces)$tongue$files[[plainTextname]][[frameNumber]]
        xyFileData <- traces_raw$files[[plainTextname]][[frameNumber]]
        
        myFileAndFrameName <- paste(plainTextname, "_", frameNumber, sep = "")
        myVowelType <- (allRowsTextGrids$text)[[frame]]
        if (mergeCategories[[item]] == TRUE){
          if (length(unlist(categories))!=0){
            myVowelType <- paste(categories, collapse = "")
          }else{
            myVowelType <- "N/A" #or something else
          }
          
        }
        
        if (length(xyFileData)>0){
          for (mark in 1:length(xyFileData)){
            itemNumber <- mark
            xCoor <- xyFileData[[mark]]$x
            yCoor <- xyFileData[[mark]]$y
            
            #build data.frame
            appendedXYFrame <- c(myFileAndFrameName, itemNumber, myVowelType, yCoor, xCoor)
            rawTraces <- rbind(rawTraces, appendedXYFrame)
          }
        }
      }
      allRowsTextGrids <- list()
    }  
  }
  
  #allRowsTextGrids extract x,y
  #textTiers
  
  #CLEAN UP
  if (unlist(rawTraces[1,3]) == "segment"){
    rawTraces <- rawTraces[-1, ] #delete the heading that is in row 1
  }
  colnames(rawTraces) <- column_names #replace auto generated heading
  rawTraces[ ,4] <- as.numeric(rawTraces[ ,4]) #x, y are ints for graphing
  rawTraces[ ,5] <- as.numeric(rawTraces[ ,5])
  
  #a[order(factor(a$x, levels = reference)),] #sorting given user input
  # if (length(unlist(categoriesAll)) > 0 && max(lapply(categoriesAll, nchar)!=0)){
  #     rawTraces <- rawTraces[order(factor(rawTraces$segment, levels = unlist(categoriesAll))), ]
  # }
  return(rawTraces)
}
```

```{r}
tracesWithoutTier <- function(metaDataFilePath, layerName){
  #length(unique(rawTraces$file_number))
  metaData <- fromJSON(file = metaDataFilePath)
  #fileName <- metaData$files[[38]]$name
  #9
  #getting #2 
  filenamexy <- list()
  xvalues <- list()
  yvalues <- list()
  rawTraces <- data.frame()
  column_names <- c('file_number', 'itemNumber_inFile', 'segment', 'x', 'y')
  rawTraces <- rbind(rawTraces, column_names)
  for (file in 1:length(metaData$files)){
    fileName <- fileName <- metaData$files[[file]]$name
    for (fileTrace in 1:length(metaData$traces[[layerName]]$files[fileName][[1]])){
      if (length(metaData$traces[[layerName]]$files[fileName][[1]][[fileTrace]])>0){
        filenamexy <- append(filenamexy, metaData$traces[[layerName]]$files[fileName][[1]][[fileTrace]])
        #names(metaData$traces[['palate']]$files[[1]][1])
        traceNumber <- names(metaData$traces[[layerName]]$files[fileName][[1]][fileTrace])
        myFileAndFrameName <- paste(fileName, "_", traceNumber, sep = "")
        
        for (mark in 1:length(filenamexy)){
          itemNumber <- mark
          xCoor <- filenamexy[[mark]]$x
          yCoor <- filenamexy[[mark]]$y
          xvalues <- append(xvalues, xCoor)
          yvalues <- append(yvalues, yCoor)
          #build data.frame
          #appendedXYFrame <- c(myFileAndFrameName, mark, layerName, yCoor, xCoor)
          appendedXYFrame <- c(myFileAndFrameName, mark, layerName, yCoor, xCoor)
          rawTraces <- rbind(rawTraces, appendedXYFrame)
        }
        filenamexy <- list()
        xvalues <- list()
        yvalues <- list()
      }
    }
    #done getting xy in file
  }
  
  # colnames(rawTraces) <- rawTraces[1, ] #replace auto generated heading
  rawTraces <- rawTraces[-1, ] #delete the heading that is in row 1
  # rawTraces[ ,4] <- as.numeric(rawTraces[ ,4]) #x, y are ints for graphing
  # rawTraces[ ,5] <- as.numeric(rawTraces[ ,5])
  return(rawTraces)
}
```

```{r}
textGridDataFile <- read_textgrid('/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012/File001.TextGrid')
textGridDataFile
```


```{r}
loadAllTraces <- function(directory_name){
  
  metaDataFile <- paste(directory_name, "metadata.json", sep = "/") 
  if (!file.exists(metaDataFile)){
    stop("metadata file does not exist in given directory")
  }
  
  metaData <- fromJSON(file = metaDataFile)
  filesAll <- metaData$files
  
  #some initial set-up
  rawTraces <- data.frame()
  column_names <- c('file_number', 'itemNumber_inFile', 'segment', 'x', 'y')
  rawTraces <- rbind(rawTraces, column_names)
  allRowsTextGrids <- list()

  #beginning for loop
  #but now, you don't know categoriesAll!
  #replace with layer loop
  for (item in 1:length(metaData$traces)){
    #item, instead of 'tongue' or 'palate'
    traces_raw <- metaData$traces[[item]]
    
    for (individualFile in 1:length(filesAll)){
      #accessing text grid files
      recording_name <- filesAll[[individualFile]]$.TextGrid
      plainTextname <- filesAll[[individualFile]]$name
      #used to access text grid files
      fullFilePath <- file.path(directory_name, recording_name)

      cur_recording <- traces_raw$files[[(filesAll[[individualFile]]$name)]]
      
      if (is.null(cur_recording)){
        listExists <- 0
      }else{
        listExists <- max(unlist(lapply(traces_raw$files[[(filesAll[[individualFile]]$name)]], length)))
      }
      
      #read text grid if, there are some annotations
      #ok, and then if text grid crashes... still get it, but label it as layer name?? only. 
      if (listExists > 1){
        errorCode = 0
        #read in text grid data but only if recording > 0
        #Reading Text Grid
        tryCatch({
          textGridDataFile <- read_textgrid(fullFilePath)
        }, error = function(e){
          errorCode = 1
          message("cannot open textgrid")
          message(plainTextname)
          
          if(errorCode==1){ 
            #there is an error opening the TextGrid. #therefore, get the xy data from this file, and label with layer name...
            #just add xy data immediately to rawTraces?
            filenamexy <- list()
            xvalues <- list()
            yvalues <- list()
            for (fileTrace in 1:length(cur_recording)){
              if (length(cur_recording[[fileTrace]])>0){
                filenamexy <- append(filenamexy, cur_recording[[fileTrace]])
                traceNumber <- names(cur_recording[fileTrace])
                layer <- names(metaData$traces[item])
                myFileAndFrameName <- paste(plainTextname, "_", traceNumber, sep = "")
  
                for (mark in 1:length(filenamexy)){
                  itemNumber <- mark
                  xCoor <- filenamexy[[mark]]$x
                  yCoor <- filenamexy[[mark]]$y
                  xvalues <- append(xvalues, xCoor)
                  yvalues <- append(yvalues, yCoor)
                  rawTraces <<- rbind(rawTraces, c(myFileAndFrameName, mark, layer, yCoor, xCoor))
                }
                filenamexy <- list()
                xvalues <- list()
                yvalues <- list()
              }
            }
            
          }
          #next section is actually looking at TextGrid
        })
        
        if(errorCode==1){ #skip this file and move onto next
          #doesn't even do anything
          next
        }

        #time to parse TIERS
        intervalData <- textGridDataFile[textGridDataFile$tier_type == "IntervalTier", ]
        intervalData <- intervalData[nchar(intervalData$text) !=0, ] 
        
        fileNumber <- (intervalData$file)[1]
        
        
        df <- intervalData
        
        #attaching midpoint and plainTextname for later textgrid access
        df <- df %>% mutate(mid_point = (df$xmin + df$xmax)/2) #THIS IS FINE
        df <- df %>% mutate(plainTextName = plainTextname)
        
        textTiers <-  textGridDataFile[textGridDataFile$tier_type == "TextTier",]
        
        if (nrow(df) > 0){
          #1) using df min and max, isolate textTiers fragment
          #2) out of fragment, find textTier closest to midpoint
          frameNumberList <- list()
          for (midpoint in 1:length(df$mid_point)){
            min <- (df$xmin)[[midpoint]]
            max <- df$xmax[[midpoint]]
            textTierSection <- textTiers[textTiers$xmin >= min & textTiers$xmin <= max, ]
            
            if (nrow(textTierSection)!=0){
              frameNumber <- (textTierSection[which.min(abs(textTierSection$xmin - df$mid_point[[midpoint]])), ])$text
            }else{ #special case
              frameNumber <- (textTiers[which.min(abs(textTiers$xmin - df$mid_point[[midpoint]])), ])$text
            }
            frameNumberList = append(frameNumberList, frameNumber)
          }
          
          frameNumberList <- unlist(frameNumberList)
          df <- df %>% mutate(frame = frameNumberList)
          
          for (midpoint in 1:length(df$mid_point)){
            allRowsTextGrids <- rbind(allRowsTextGrids, data.frame(df[midpoint,])) #necessary in case multiple text grid files
          }
        }
        
        
      }
    }
    #return(allRowsTextGrids)
    #extract xy data separately once we have all the data
    
    #this should be fine, not hard coded to 'tongue' as layer name
    #print(names(metaData$traces[item]))
    #print(length(allRowsTextGrids$frame))
    if (length(allRowsTextGrids$frame) > 0){ #R should already be able to do this. 
      for(frame in 1:length(allRowsTextGrids$frame)){
        frameNumber = (allRowsTextGrids$frame)[[frame]]
        plainTextname <- allRowsTextGrids$plainTextName[[frame]]
        #xyFileData <- (metaData$traces)$tongue$files[[plainTextname]][[frameNumber]]
        xyFileData <- traces_raw$files[[plainTextname]][[frameNumber]]
        
        myFileAndFrameName <- paste(plainTextname, "_", frameNumber, sep = "")
        myVowelType <- (allRowsTextGrids$text)[[frame]]
        
        
        if (length(xyFileData)>0){
          for (mark in 1:length(xyFileData)){
            itemNumber <- mark
            xCoor <- xyFileData[[mark]]$x
            yCoor <- xyFileData[[mark]]$y
            
            #build data.frame
            appendedXYFrame <- c(myFileAndFrameName, itemNumber, myVowelType, yCoor, xCoor)
            rawTraces <- rbind(rawTraces, appendedXYFrame)
          }
        }
      } 
    }
    allRowsTextGrids <- list()
  }
  
  #allRowsTextGrids extract x,y
  #textTiers
  
  #CLEAN UP
  if (unlist(rawTraces[1,3]) == "segment"){
    rawTraces <- rawTraces[-1, ] #delete the heading that is in row 1
  }
  colnames(rawTraces) <- column_names #replace auto generated heading
  rawTraces[ ,4] <- as.numeric(rawTraces[ ,4]) #x, y are ints for graphing
  rawTraces[ ,5] <- as.numeric(rawTraces[ ,5])
  
  #a[order(factor(a$x, levels = reference)),] #sorting given user input
  # if (length(unlist(categoriesAll)) > 0 && max(lapply(categoriesAll, nchar)!=0)){
  #     rawTraces <- rawTraces[order(factor(rawTraces$segment, levels = unlist(categoriesAll))), ]
  # }
  return(rawTraces)
}
```


```{r}
#COLOR PALETTES:
#par(mfrow=c(1, 1))
#display.brewer.pal(9, "RdBu")
#brewer.pal(9, "RdYlBu")[[1]] #accessing individual colors
#https://www.datanovia.com/en/blog/the-a-z-of-rcolorbrewer-palette/
#display.brewer.all(colorblindFriendly = TRUE)
```
Sort in order by angle 
```{r}
#Return order of x values:
sortedOrder <- function(listX){ #Sort by angle
  order_x <- order(listX)
  return(order_x)
}
```

Calculate Intersection 
```{r}
calculateIntersection2 <- function(radiusPrevious, radiusNext, anglePrevious, angleRay, angleNext){

  differenceInTheta = angleNext - anglePrevious
  differenceInRay = angleRay - anglePrevious
  differenceInRadius = radiusNext - radiusPrevious
  
  return ( radiusPrevious + differenceInRay/differenceInTheta * differenceInRadius  )
}
```

Reading in data:
```{r}
# Import the text file
read_in_data <- function(extractedData){
  dataR <- extractedData
  
  #split by vowel type
  split_data <- split(dataR, dataR$segment)
  uniqueSegments <- unique(dataR$segment)
  
  dataOfEachCurveNNj <- list()
  for (segment in 1:length(uniqueSegments)){
    dataOfEachCurveNNj[[uniqueSegments[[segment]]]] <- split(split_data[[uniqueSegments[[segment]]]], split_data[[uniqueSegments[[segment]]]]$file_number)
  }
  
  return(dataOfEachCurveNNj)
}


get_unique_segments <- function(extractedData){
  dataR <- extractedData
  uniqueSegments <- unique(dataR$segment)

  return(uniqueSegments)
}
```

```{r}
identifyXAverage <- function(myXY_data){ #the x y axis are rotate left 90 degrees, so go based off x axis
  xmin =  min(myXY_data[c(5)])
  xmax =  max(myXY_data[c(5)])

  return((xmin + xmax)/2) 
}

identifyPlotBounds <- function(compiledList){
  xmin = 2
  xmax = -2
  ymin = 2
  ymax = -2
  
  for (segment in 1:length(compiledList)){
    for (trace in 1:length(compiledList[[segment]])){
      tempxmin <- min(compiledList[[segment]][[trace]][1,])
      tempxmax <- max(compiledList[[segment]][[trace]][1,])
      tempymin <- min(compiledList[[segment]][[trace]][2,])
      tempymax <- max(compiledList[[segment]][[trace]][2,])
      
      if (tempxmin < xmin){
        xmin <- tempxmin
      }
      
      if (tempxmax > xmax){
        xmax <- tempxmax
      }
      
      if (tempymin < ymin){
        ymin <- tempymin
      }
      
      if (tempymax > ymax){
        ymax <- tempymax
      }
    }
    
  }
  
  return(c(xmin, xmax, ymin, ymax))
}
#identifyPlotBounds(compiledList)
#use .5, use range, override (origin is -10) for shifting coordinates what about y but ok
```


Setting up 3D array for each segment: contains 1) x values 2) y values 3) angle in radians 4) radius
```{r}
formating_data <- function(dataOfEachCurveNNj, uniqueSegments, origin.x = .5, scaling.factor = 800/600){
  polarTraces <- list()
  
  for (segment in 1:length(dataOfEachCurveNNj)){
    listofarrays <- list()
    for (i in 1:length(dataOfEachCurveNNj[[segment]])){ #for each curve
      n_rows <- 4 # no need for slope 
      n_cols <- length(dataOfEachCurveNNj[[segment]][[i]][,1])
      myCurveMatrix <- matrix(0, nrow = n_rows, ncol = n_cols) #each individual 2D array
      
      #adjusted x and y values around the center
      xvalues <- (dataOfEachCurveNNj[[segment]][[i]][c(5)][[1]] * scaling.factor) - (origin.x*scaling.factor) 
      #include parameter for aspect ratio
      yvalues <- 1 - dataOfEachCurveNNj[[segment]][[i]][c(4)][[1]]
      
      
      anglevalues <- list()
      
      for (j in 1: n_cols){
        anglevalues <- append(anglevalues, atan2(yvalues[[j]], xvalues[[j]]) )
      }
      
      #sort by angle
      anglevalues <- unlist(anglevalues)
      
      theOrderForSorting <- sortedOrder(anglevalues)
      xvaluesSorted <- xvalues[theOrderForSorting]
      yvaluesSorted <- yvalues[theOrderForSorting]
      anglevalues <- anglevalues[theOrderForSorting]
      
      
      for (j in 1:n_cols){
        myCurveMatrix[1,j] <- xvaluesSorted[[j]]
        myCurveMatrix[2,j] <- yvaluesSorted[[j]]
        myCurveMatrix[3,j] <- anglevalues[[j]] #angle in relation to (0,0)
        myCurveMatrix[4,j] <- (yvaluesSorted[[j]]^2 + xvaluesSorted[[j]]^2)^.5 #radius in relation to (0,0)
        
      }
      
      listofarrays[[i]] <-myCurveMatrix
    }
    polarTraces[[uniqueSegments[[segment]]]] <- listofarrays
  }
  return(polarTraces)
}

```

create intersection matrix for each segment
where column is the angle, and the row is the value of the intersection of that angle for each trace in the segment, NA if none
```{r}
find_intersection_with_ray <- function(formatedData, dataOfEachCurveNNj, uniqueSegments, rayIncrement){ #ie compiledList
  
  matrixIntersection <- list()
  
  #start set up unique segment 
  for (segment in 1:length(uniqueSegments)){
    matrixIntersection[[uniqueSegments[[segment]]]] <- matrix(NA, nrow = length(formatedData[[segment]]), ncol = (3.14/rayIncrement))
  }
  #end set up
  count <- 0
   #for each extending radius
    for (angleRay in seq(from=0, to= 3.14, by= rayIncrement)){
      count <- count + 1
      for (segment in 1:length(uniqueSegments)){ #and for each segment
      
       for (individualTrace in seq(length(dataOfEachCurveNNj[[segment]]))){ #for each trace in the segment (alphabetical??)
         
         for (individualPoint in 1:(length(formatedData[[segment]][[individualTrace]][1, all()])-1)){ #for each point on the trace, find intersection
          #find the right two points the angle falls between for each individual trace
           
           if (angleRay <= formatedData[[segment]][[individualTrace]][3, individualPoint +1]){
             if (angleRay >= formatedData[[segment]][[individualTrace]][3, individualPoint]){ 
               
               #print("found intersection with the following ray angle")
               
               myIntersection <- calculateIntersection2(
                                                
                                                                    (formatedData[[segment]][[individualTrace]][4,individualPoint]), 
                                                                     (formatedData[[segment]][[individualTrace]][4,individualPoint + 1]), 
                                                                     (formatedData[[segment]][[individualTrace]][3,individualPoint]), 
                                                                     angleRay, 
                                                                     (formatedData[[segment]][[individualTrace]][3,individualPoint + 1]) 
                                                                     
                                                                     )
               # if (count > 122 && count < 128){
               #   print("reached problematic angle, intersection:")
               #   print(myIntersection)
               #   print("angle")
               #   print(angleRay/rayIncrement)
               # }
              
               if (is.na(myIntersection)){
                 print("NA FOUND:", angleRay/rayIncrement)
               }
               #store value
               #matrixIntersection[[segment]][[individualTrace, angleRay/rayIncrement]] <- myIntersection
               matrixIntersection[[segment]][[individualTrace, count]] <- myIntersection
               # if (count == 124 || count == 125 || count == 126){
               #   print(angleRay/rayIncrement)
               #   print(matrixIntersection[[segment]][[individualTrace, angleRay/rayIncrement]])
               # }
               break
             }
           }
               
         }
         
     } #end individual trace for loop 
      
    } #end segment for loop
  
  } #end angle ray for loop 
  return(matrixIntersection) # columns for rays
} 
```

```{r}
#POST PROCESSING

my_palette1 <- c(
  "#FF0000", "#800080", "#0000FF",   # Red, Purple, Blue
  "#FF3333", "#993399", "#3366FF",   # Light Red, Light Purple, Light Blue
  "#FF6666", "#B366CC", "#6699FF",   # Medium Red, Medium Purple, Medium Blue
  "#FF9999", "#CC99FF", "#99BBFF",   # Dark Red, Dark Purple, Dark Blue
  "#FFCCCC", "#E6CCFF", "#CCE6FF"    # Lighter Red, Lighter Purple, Lighter Blue
)

plotStyleTraces <- function(matrixIntersection, polarTraces, dataOfEachCurveNNj, uniqueSegments, palette = c(),
                            rayIncrement, points.display = FALSE, mean.lines = TRUE, means.styles = c(),
                            bands.fill = TRUE, bands.lines = FALSE, legend.position = "topleft", 
                            standard.deviation.styles = "l", pdf.filename = c(), png.filename = c(), 
                            plot.ticks = FALSE, plot.labels = FALSE, legend.size = 3, transparency = 0.37,
                            bands.linewidth = 0.3, legend.linewidth = 5, means.linewidth = 3, tick.size = 2, 
                            maskCategories = c()){
  
  plotbounds <- identifyPlotBounds(polarTraces)
  
  standardDeviation <- list()
  averagedRX <- list()
  averagedRY <- list()
  
  for (segment in 1:length(uniqueSegments)){
    averagedRX[[uniqueSegments[[segment]]]] <- list()
    averagedRY[[uniqueSegments[[segment]]]] <- list()
    
    standardDeviation[[uniqueSegments[[segment]]]] <- list()
    
    for (ray in 1:length(matrixIntersection[[segment]][1, all()])){
      if (!is.na(colMeans(matrixIntersection[[segment]], na.rm = TRUE)[[ray]])){ 
        #as long as there is a mean for each column, store the value
        averagedRX[[segment]] <- append(averagedRX[[segment]], cos(rayIncrement*ray) * colMeans(matrixIntersection[[segment]], na.rm = TRUE)[[ray]] )
        averagedRY[[segment]] <- append(averagedRY[[segment]], sin(rayIncrement*ray) * colMeans(matrixIntersection[[segment]], na.rm = TRUE)[[ray]] )
        standardDeviation[[segment]] <- append(standardDeviation[[segment]], sd(matrixIntersection[[segment]][all(), ray], na.rm = TRUE))
      } 
      else{
        averagedRX[[segment]] <- append(averagedRX[[segment]], NA)
        averagedRY[[segment]] <- append(averagedRY[[segment]], NA)
        standardDeviation[[segment]] <- append(standardDeviation[[segment]], NA)
      }
    }
    averagedRX[[segment]] <- unlist(averagedRX[[segment]])
    averagedRY[[segment]] <- unlist(averagedRY[[segment]])
    standardDeviation[[segment]] <- unlist(standardDeviation[[segment]])
  }
  
  
  #we now have the standard deviation
  xSDHigh <- list()
  xSDLow <- list()
  ySDHigh <- list()
  ySDLow <- list()  
  for (segment in 1:length(uniqueSegments)){
    
    xSDHigh[[uniqueSegments[[segment]]]] <- list()
    xSDLow[[uniqueSegments[[segment]]]] <- list()
    ySDHigh[[uniqueSegments[[segment]]]] <- list()
    ySDLow[[uniqueSegments[[segment]]]] <- list()
    
    for (i in 1:length(standardDeviation[[segment]])){
      
      if (!is.na(standardDeviation[[segment]][[i]])){
        xSDHigh[[segment]]<- append(xSDHigh[[segment]], cos(i*rayIncrement) *standardDeviation[[segment]][[i]] + averagedRX[[segment]][[i]])
        xSDLow[[segment]] <-  append( xSDLow[[segment]], -1*cos(i*rayIncrement) *standardDeviation[[segment]][[i]] + averagedRX[[segment]][[i]])
        
        ySDHigh[[segment]] <- append(ySDHigh[[segment]], sin(i*rayIncrement) *standardDeviation[[segment]][[i]] + averagedRY[[segment]][[i]])
        ySDLow[[segment]] <-  append(ySDLow[[segment]], -1*sin(i*rayIncrement) *standardDeviation[[segment]][[i]] + averagedRY[[segment]][[i]])
        
      }
      # else{
      #   xSDHigh[[segment]]<- append(xSDHigh[[segment]], NA)
      #   xSDLow[[segment]] <-  append( xSDLow[[segment]], NA)
      #   
      #   ySDHigh[[segment]] <- append(ySDHigh[[segment]], NA)
      #   ySDLow[[segment]] <-  append(ySDLow[[segment]], NA)
      # }
      
    }
  }
  
  xPlotAverage <- (plotbounds[[1]] + plotbounds[[2]])/2
  yPlotAverage <- (plotbounds[[3]] + plotbounds[[4]])/2
  
  x_ticks <- c(round(plotbounds[[1]],2), round(xPlotAverage,2), round(plotbounds[[2]],2))
  y_ticks <- c(round(plotbounds[[3]],2), round(yPlotAverage,2), round(plotbounds[[4]],2))
  #else {
  #still have "ticks" just way out of bounds so that they don't show up
  # x_ticks <- c(round(plotbounds[[1]],2) + 3, round(xPlotAverage,2) + 3, round(plotbounds[[2]],2) + 3)
  # y_ticks <- c(round(plotbounds[[3]],2) + 2, round(yPlotAverage,2) + 2, round(plotbounds[[4]],2) + 2)
  
  if(plot.labels == TRUE){
    x_ticks_lables <- c(round(plotbounds[[1]],2)*100, round(xPlotAverage,2)*100, round(plotbounds[[2]],2)*100)
    y_ticks_lables <- c(round(plotbounds[[3]],2)*100, round(yPlotAverage,2)*100, round(plotbounds[[4]],2)*100)
  }else{
    x_ticks_lables <- c(NA, NA, NA)
    y_ticks_lables <- c(NA, NA, NA)
  }
  
  if (length(pdf.filename)!=0){
    #pdf.options(encoding="MacRoman")
    #pdf.options(encoding = "utf-8")
    cairo_pdf(filename = pdf.filename, family = "DejaVu Serif", width = 22 * (plotbounds[[2]] - plotbounds[[1]] - 0.05), height = 22 * (plotbounds[[4]] - plotbounds[[3]] -0.05))
    #cairo_pdf(file = pdf.filename, family = "DejaVu Serif")
    # cairo_pdf(file = pdf.filename, family = "DejaVu Serif", width = 22, height = 22)
  }
  
  if (length(png.filename)!=0){
    png(filename = png.filename, width = 4000*(plotbounds[[2]] - plotbounds[[1]] - 0.05), height = 4000 * (plotbounds[[4]] - plotbounds[[3]] -0.05), units = "px")
  }
  
  
  oldpar <- par(no.readonly = TRUE)
  on.exit(par(oldpar))
  #par(pty = "s")
  par(mar = c(0, 4.4, 0, 1.25) + 2)
  
  
  
  plot(1, type = "n", xlab = "", ylab = "", ylim = c(plotbounds[[3]], plotbounds[[4]]), xlim = c(plotbounds[[1]], plotbounds[[2]]), xaxt = "n", yaxt = "n", asp = 1, family = "DejaVu Serif", cex.axis = 20)
  
  if(plot.ticks == TRUE){
    axis(1, at = x_ticks, labels = x_ticks_lables, cex.axis = tick.size)
    axis(2, at = y_ticks, labels = y_ticks_lables, cex.axis = tick.size)
  }else{
    axis(1, at = x_ticks, labels = x_ticks_lables, tck = 0, cex.axis = tick.size)
    axis(2, at = y_ticks, labels = y_ticks_lables, tck = 0, cex.axis = tick.size)
  }
  
  if (length(palette) == 0){
    numberOfColors <- length(uniqueSegments) + 2
    paletteColors <- (brewer.pal(numberOfColors, "Set1"))[2:numberOfColors] #PuRd nice
    
  }else{
    paletteColors <- palette
  }
  
  
  for (segment in 1:length(uniqueSegments)){
    #Shading
    x1 <- rev(unlist(lapply(xSDLow[[segment]], function(x) na.omit(x)), recursive = TRUE))
    y1 <- rev(unlist(lapply(ySDLow[[segment]], function(x) na.omit(x)), recursive = TRUE))
    
    
    x2 <- rev(unlist(lapply(xSDHigh[[segment]], function(x) na.omit(x)), recursive = TRUE))
    y2 <- rev(unlist(lapply(ySDHigh[[segment]], function(x) na.omit(x)), recursive = TRUE))
    
    
    #print(xSDHigh[[segment]])
    
    #Plot the upper lower standard devation lines
    if (bands.lines == TRUE){
      lines(x1, y1, type = standard.deviation.styles, col = paletteColors[[segment]], lwd = bands.linewidth)#, ylim = c(ymin, ymax), xlim = c(xmin, xmax))
      lines(x2, y2, type = standard.deviation.styles, col = paletteColors[[segment]], lwd = bands.linewidth)
    }
    
    if (bands.fill == TRUE){
      # Create a polygon to shade the region between the arches
      polygon(c(x1, rev(x2)), c(y1, rev(y2)), col = adjustcolor(paletteColors[[segment]], alpha.f = transparency), border = NA)
    }
    
    if (length(means.styles) < length(polarTraces)){
      for (i in 1:(length(polarTraces) - length(means.styles))){
        means.styles = append(means.styles, 1)
      }
    }
    
    if (mean.lines){
      if (!all(is.na(standardDeviation[[segment]]))){
        lines(averagedRX[[segment]], averagedRY[[segment]], type = "l", lty = means.styles[[segment]], col = paletteColors[[segment]] , lwd = means.linewidth) #you could also have black...
      }else{ #differentiating if there is a standard deviation band or not, currently no differation
        lines(averagedRX[[segment]], averagedRY[[segment]], type = "l", lty = means.styles[[segment]], col = paletteColors[[segment]] , lwd = means.linewidth)
      }
    }
    
    if (points.display){
      for (trace in 1:length(polarTraces[[segment]])){
        points(polarTraces[[segment]][[trace]][1, all()], polarTraces[[segment]][[trace]][2, all()], type = "p", col = paletteColors[[segment]], asp = 1)
      }
    }
    
    # if (length(pdf.filename) == 0 && length(png.filename) == 0){
    #   legend.size = 0.6
    # }
    
    ltyNumerical = means.styles
    
    numberColumns = 1
    numberColumns = round(length(uniqueSegments)/5)
    if (numberColumns==0){
      numberColumns = 1
    }
    
    if (legend.position == "center"){
      # legend(xPlotAverage, yPlotAverage, legend = uniqueSegments,  col = paletteColors, cex = legend.size, bty = "n", lty=ltyNumerical, lwd = 5)
      legend("center", legend = if (length(maskCategories) == 0) uniqueSegments else maskCategories,  col = paletteColors, cex = legend.size, bty = "n", lty=ltyNumerical, lwd = legend.linewidth, ncol =  numberColumns)
    } else if (legend.position == "topleft"){
      # legend(plotbounds[[1]], plotbounds[[4]], legend = uniqueSegments, col = paletteColors, cex = legend.size, bty = "n", lty=ltyNumerical, lwd = 5)
      legend("topleft", legend = if (length(maskCategories) == 0) uniqueSegments else maskCategories, col = paletteColors, cex = legend.size, bty = "n", lty=ltyNumerical, lwd = legend.linewidth, ncol =  numberColumns)
    }else if (legend.position == "bottomright"){
      # legend((xPlotAverage + .5*plotbounds[[2]]), yPlotAverage,  legend = uniqueSegments, col = paletteColors, cex = legend.size, bty = "n", lty=ltyNumerical, lwd = 5, ncol = round(length(uniqueSegments)/5))
      legend("bottomright",  legend = if (length(maskCategories) == 0) uniqueSegments else maskCategories, col = paletteColors, cex = legend.size, bty = "n", lty=ltyNumerical, lwd = legend.linewidth, ncol =  numberColumns)
    }
  }
  
  if(length(pdf.filename)!=0 || length(png.filename)!=0 ){
    dev.off()
  }
  
}
```

PUTTING CONVERTING TO RADIANS ALL TOGETHER
```{r}
makeTracesPolar <- function(rawTraces, origin.algorithm = "BottomMiddle", origin.x = NA, scaling.factor = 800/600){
  
  uniqueSegments <- get_unique_segments(rawTraces)
  dataOfEachCurveNNj <- read_in_data(rawTraces)
  xaverage <- identifyXAverage(rawTraces)
  
  
  if (origin.algorithm == "BottomMiddle"){
    if (is.na(origin.x)){
      origin.x = .5
    }
  }else if (origin.algorithm == "BottomMean"){
    origin.x = xaverage
  }
  
  polarTraces <- formating_data(dataOfEachCurveNNj, uniqueSegments, origin.x = origin.x, scaling.factor = scaling.factor)
  return(polarTraces)
}

#polarTraces <- makeTracesPolar(myXY_data = myXY_data, origin.algorithm = "BottomMean")
#592, 412 : russian palatals
#800, 600 : others
```

```{r}
plotTraces <- function(rawTraces, polarTraces, interval = 1, mean.lines = TRUE, points.display = FALSE,
                       palette = c(), bands.lines = FALSE, bands.fill = TRUE, legend.position = "topleft",
                       means.styles = c(), standard.deviation.styles = "l", plot.ticks = FALSE, plot.labels = FALSE,
                       legend.size = 3, transparency = 0.37, pdf.filename = c(), bands.linewidth = 0.3,
                       png.filename = c(), legend.linewidth = 5, means.linewidth = 3, tick.size = 2,
                       maskCategories = c()){
  
  rayIncrement = 3.14159/180 * interval
  
  uniqueSegments <- get_unique_segments(rawTraces)
  dataOfEachCurveNNj <- read_in_data(rawTraces)
  
  matrixIntersection <- find_intersection_with_ray(polarTraces, dataOfEachCurveNNj, uniqueSegments, rayIncrement)
  
  plotStyleTraces(matrixIntersection = matrixIntersection, polarTraces = polarTraces, 
                  dataOfEachCurveNNj = dataOfEachCurveNNj, uniqueSegments = uniqueSegments, 
                  rayIncrement = rayIncrement, mean.lines = mean.lines, points.display = points.display,
                  palette = palette, bands.lines = bands.lines, legend.position = legend.position, 
                  bands.fill = bands.fill, means.styles = means.styles, standard.deviation.styles = standard.deviation.styles,
                  plot.ticks = plot.ticks, legend.size = legend.size, transparency = transparency, pdf.filename = pdf.filename,
                  bands.linewidth = bands.linewidth, plot.labels = plot.labels, png.filename = png.filename, 
                  legend.linewidth = legend.linewidth, means.linewidth = means.linewidth, tick.size = tick.size,
                  maskCategories = maskCategories)
}
```

```{r}
#directory_name <- "/Users/yayaorigami/Documents/plinguistics/IETestData"
#directory_name <- "/Users/yayaorigami/Documents/plinguistics/ultrasound-data-RussianPalatals-202012/"
#directory_name <- "/Users/yayaorigami/Documents/plinguistics/Dataset3"
#directory_name <- "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012"
categories <- c("o","y", "e", "i")
categories <- c('u', 'ɯ', 'o', 'ɑ', 'i', 'y', 'e', 'ø')

# myXY_data <- loadTraces("/Users/yayaorigami/Documents/plinguistics/IETestData", categoriesAll = c("o", "i"))
#myXY_data <- loadAllTraces("/Users/yayaorigami/Documents/plinguistics/IETestData")

# myXY_data <- loadTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012",categoriesAll  = list(c("ɫ","n"), c("lʲ", "nʲ"), c("")), layersAll = c('tongue','tongue','palate'), mergeCategories = TRUE) #"ɫ", "lʲ", "n", "nʲ"
# myXY_data <- loadTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012")

# myXY_data <- loadTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012", tiernameAll = c("cons", ""), categoriesAll = list(c("n", "nʲ"), c("")), layersAll = c('tongue', 'palate'))
#myXY_data <- loadAllTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012")

# myXY_data <- loadTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012", categoriesAll = list(c("n", "nʲ")))
# myXY_data <- loadTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012", categoriesAll = list(c(), c("")), tiernameAll = c("cons", ""), layersAll = c('tongue','palate'))
myXY_data <- loadAllTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012")

# myXY_data <- loadTraces(directory_name = "/Users/yayaorigami/Documents/plinguistics/updatedRussianPalatals/ultrasound-data-RussianPalatals-202012")

# myXY_data <- loadTraces("~/Documents/plinguistics/Dataset3/", categoriesAll = list(c('u', 'ɯ', 'o', 'ɑ'), c('i', 'y', 'e', 'ø')), mergeCategories = TRUE)
# #does not crash if "cons" tier specified to palate, which is good
myXY_data
#inherits(c(), "NULL")

```
```{r}
polarTraces <- makeTracesPolar(myXY_data, scaling.factor = 592/412, origin.algorithm = "BottomMean")
plotTraces(myXY_data, polarTraces, interval = 1, legend.size = 1, plot.labels = TRUE, plot.ticks = TRUE, tick.size = 1)
```
Four traces each. So 4 by 4 per angle ray. 
Intersections for each ray, with EACH curve -- should have that from matrixIntersection 
```{r}
rayIncrement = 3.14159/180 * 1 #30 degree for test
  
uniqueSegments <- get_unique_segments(myXY_data)
dataOfEachCurveNNj <- read_in_data(myXY_data)
  
matrixIntersection <- find_intersection_with_ray(polarTraces, dataOfEachCurveNNj, uniqueSegments, rayIncrement)
```

For each ray angle (5), calculate all differences. Take mean, and standard deviation. 
Two 1D lists

```{r}
differencePlot <- function(rawTraces, polarTraces, interval = 1){
  rayIncrement = 3.14159/180 * interval #30 degree for test
  uniqueSegments <- get_unique_segments(rawTraces)
  dataOfEachCurveNNj <- read_in_data(rawTraces)
    
  matrixIntersection <- find_intersection_with_ray(polarTraces, dataOfEachCurveNNj, uniqueSegments, rayIncrement)
  
  meanDifference <- list()
  standardDeviation <- list()
  redLine <- list()
  rayIncrement <- 1
  plotbounds <- identifyPlotBounds(polarTraces)
  
  for (ray in 1:length(matrixIntersection[[1]][1, all()])){
    #[[1]] and [[2]] for matrixIntersection ONLY
    if (!is.na(colMeans(matrixIntersection[[1]], na.rm = TRUE)[[ray]]) && !is.na(colMeans(matrixIntersection[[2]], na.rm = TRUE)[[ray]]) ){ 
      #both are not empty... because no point taking difference of like 16.59 - NA right?
      segment1 <- (matrixIntersection[[1]][all(), ray])[!is.na(matrixIntersection[[1]][all(), ray])]
      segment2 <- (matrixIntersection[[2]][all(), ray])[!is.na(matrixIntersection[[2]][all(), ray])]
  
      differences <- list()
      #4 by 4 x grid
      for (item1 in 1:length(segment1)){
        for (item2 in 1:length(segment2)){
          differences <- append(differences, segment1[item1] - segment2[item2])
        }
      }
      differences <- unlist(differences)
      meanDifference <- append(meanDifference, mean(differences))
      standardDeviation <- append(standardDeviation, sd(differences))
      #what is proper scaling? 
      redLine <- append(redLine, mean(differences)/(60*sd(differences)))
    }else{
      #for consistency when matching up with the angle loop
      meanDifference <- append(meanDifference, NA)
      standardDeviation <- append(standardDeviation, NA)
      redLine <- append(redLine, NA)
      
    }
    differences <- list() #reset/clear for next angle ray
  }
  meanX <- list()
  for (ray in 1:length(matrixIntersection[[1]][1, all()])){
    meanX <- append(meanX, cos(rayIncrement*ray * pi/180))
  }
  #plot label should be this cos converted to degrees.
  #so times 180/pi
  
  xSDHigh <- list()
  xSDLow <- list()
  ySDHigh <- list()
  ySDLow <- list()  

  for (ray in 1:length(matrixIntersection[[1]][1, all()])){
  
    xSDHigh<- append(xSDHigh, cos(rayIncrement*ray*pi/180)*(standardDeviation[[ray]]) + meanX[[ray]])
    xSDLow <-  append(xSDLow, cos(rayIncrement*ray*pi/180)*(-standardDeviation[[ray]]) + meanX[[ray]])
  
    ySDHigh <- append(ySDHigh, sin(rayIncrement*ray*pi/180)*(meanDifference[[ray]] + standardDeviation[[ray]]))
    ySDLow <-  append(ySDLow, sin(rayIncrement*ray*pi/180)*(meanDifference[[ray]] - standardDeviation[[ray]]))
    
  }
  
  x1 <- rev(unlist(lapply(xSDLow, function(x) na.omit(x)), recursive = TRUE))
  y1 <- rev(unlist(lapply(ySDLow, function(x) na.omit(x)), recursive = TRUE))
  
  
  x2 <- rev(unlist(lapply(xSDHigh, function(x) na.omit(x)), recursive = TRUE))
  y2 <- rev(unlist(lapply(ySDHigh, function(x) na.omit(x)), recursive = TRUE))
    
  
  # labelsList <- c(round(min(x1)*180/pi), round((min(x1) + max(x2)/2)*180/pi), round(max(x2)*180/pi))
  # x_ticks <- c(round(plotbounds[[1]],2), round((plotbounds[[2]] + plotbounds[[1]])/2,2), round(plotbounds[[2]],2))
  #meanDifference
  
  axisX2 <- list()
  axisX2 <- lapply(meanX, function(x) round(x*180/pi))
  axisX2 <- seq(1,length(matrixIntersection[[1]][1,all()]), interval)
  #axisX2 <- lapply(axisX2, function(x) -(x-90))
  axisX <- lapply(lapply(meanX, function(x) x*180/pi), function(x) round(x))
  
  secondYAxis <- seq(min(y1), max(y2), (max(y2) - min(y1))/6)
  secondYAxisLabes <- lapply(secondYAxis, function(x) round(x*60,2))
  
  plot(meanX, meanDifference, type = "l", col = "blue", lwd = 2, ylim = c(min(y1), max(y2)), xlim = c(min(x1), max(x2)), xaxt = "n", xlab = "angle from origin", ylab = "mean difference")
  axis(1, at = meanX, labels = axisX, tck = 0)
  
  axis(side=4, at = secondYAxis, labels=secondYAxisLabes, col="red", col.axis="black")
  #mtext("z score", side = 4, line = 1.5)
  lines(x1, y1, col = "blue", type = "l", lwd = 1)#, ylim = c(ymin, ymax), xlim = c(xmin, xmax))
  lines(x2, y2, col = "blue", type = "l", lwd = 1)
  polygon(c(x1, rev(x2)), c(y1, rev(y2)), col = adjustcolor( "blue", alpha.f = 0.37), border = NA)
  lines(meanX, unlist(redLine), col = "red", lwd = 2)
  abline(h=0.0, lty = 2)
  abline(h=seq(min(y1), max(y2), (max(y2) - min(y1))/6), col="red", lty="dotted")
  
  indices <- which(unlist(redLine) %in% min(unlist(redLine), na.rm = TRUE))
  #print(redLine[[indices]])
  abline(v = unlist(meanX)[[indices]], col = "red")
  
  indices <- which(unlist(redLine) %in% max(unlist(redLine), na.rm = TRUE))
  print(redLine[[indices]])
  abline(v = unlist(meanX)[[indices]], col = "red")
  
}
cairo_pdf("testingDifferencePlot.pdf")
differencePlot(myXY_data, polarTraces)
dev.off()
```


```{r}
polarTraces <- makeTracesPolar(myXY_data = myXY_data, scaling.factor = 592/412, origin.algorithm = "BottomMean")
plotTraces(myXY_data = myXY_data, compiledList = polarTraces, points.display = FALSE, bands.lines = TRUE, bands.fill = TRUE, transparency = 0.37, mean.lines = TRUE, means.styles =  c(2, 1, 1, 1, 1, 2, 1, 2), legend.position = "topleft", plot.labels = TRUE, legend.size = 1.0, legend.linewidth = 1.5, means.linewidth = 1.5, tick.size = 1.2, bands.linewidth = .3, palette = c(
  
  "#FF3366", "#FF3366",
  "#FF9999", "#FF9999", 
  "#0000FF", "#0000FF",  
  "#99BBFF", "#99BBFF"
))#, png.filename = "ok4.png")
```
```{r}
polarTraces <- makeTracesPolar(myXY_data, origin.algorithm = "BottomMean")
plotTraces(myXY_data, polarTraces, legend.size = 1, palette = c(
  
  "#FF3366", "#0000FF"
), maskCategories = c("back vowels: u, ɯ, o, ɑ", "front vowels: i, y, e, ø"), legend.position = "bottomright")
#
```
```{r}
polarTraces <-  makeTracesPolar(myXY_data = myXY_data, origin.algorithm = "BottomMean")
plotTraces(myXY_data, polarTraces, palette = c("purple", "orange", "black"), maskCategories = c("ɫ, n", "lʲ, nʲ", "palate"), pdf.filename = "RusPal_alllevels.pdf")
```

Set1, png resolution, topleft, tiername bug
Merged n, l, categories:

Checking sizes IS A FUNCTION (that you will not be able to currently use)
```{r}
#dataOfEachCurveNNj <- read_in_data_file_path(file_path)

dataOfEachCurveNNj <- read_in_data(myXY_data)
uniqueSegments <- get_unique_segments(myXY_data)

checkSizes <- function(dataOfEachCurveNNj, uniqueSegments){
  for (segment in 1:length(dataOfEachCurveNNj)){
    print(names(dataOfEachCurveNNj)[[segment]])
    print(length(dataOfEachCurveNNj[[segment]]))
    sizes <- list()
    print("number of points per curve")
    for (curve in 1:length(dataOfEachCurveNNj[[segment]])){
      sizes <- append(sizes, length(dataOfEachCurveNNj[[segment]][[curve]][[1]]) )
    }
    print(unlist(sizes))
  }
}

checkSizes(dataOfEachCurveNNj, uniqueSegments)
uniqueSegments
```
Testing labelling function:
```{r}
split_data <- split(myXY_data, myXY_data$segment)
uniqueSegments <- unique(myXY_data$segment)
#split_data
#uniqueSegments

uniqueSegments[[2]]
split_data[[uniqueSegments[[2]]]]


dataOfEachCurveNNj <- list()
for (segment in 1:length(uniqueSegments)){
  dataOfEachCurveNNj[[uniqueSegments[[segment]]]] <- split(split_data[[uniqueSegments[[segment]]]], split_data[[uniqueSegments[[segment]]]]$file_number)
}

dataOfEachCurveNNj[[2]]
```
```{r}
dataOfEachCurveNNj <- read_in_data(myXY_data)
uniqueSegments <- get_unique_segments(myXY_data)

checkSizes <- function(dataOfEachCurveNNj, uniqueSegments){
  for (segment in 1:length(dataOfEachCurveNNj)){
    print(names(dataOfEachCurveNNj)[[segment]])
    print(length(dataOfEachCurveNNj[[segment]]))
    sizes <- list()
    print("number of points per curve")
    for (curve in 1:length(dataOfEachCurveNNj[[segment]])){
      sizes <- append(sizes, length(dataOfEachCurveNNj[[segment]][[curve]][[1]]) )
    }
    print(unlist(sizes))
  }
}

checkSizes(dataOfEachCurveNNj, uniqueSegments)
uniqueSegments
nchar("MathTheoryIntegralCalculationMultipleVariables.pdf")
```

